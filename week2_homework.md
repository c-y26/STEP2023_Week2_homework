# Week2

## 宿題1

### プログラムの実行方法

以下のコマンドを実行：

    python3 hash_table.py

### アルゴリズムの説明
本課題で取り組んだのは、以下の4点である。

1. deleteの実装
2. ハッシュテーブルのテーブルサイズを素数に
3. 再ハッシュの実装
4. ハッシュ関数の改良

#### ・deleteの実装
- 同じハッシュ値を持つitem同士は単方向リストで連結されている。
- SampleCodeから、最も新しい要素がnextポインタとして、ハッシュテーブルへのアドレスを指していることがわかる。
- 最も新しい要素を削除する場合に限り、特別な処理が必要

#### ・ハッシュテーブルのテーブルサイズを素数にする
- 素数の生成方法：エラトステネスのふるいを用いる
    - 計算量は、O(NloglogN)で、ほぼO(N) 

#### ・再ハッシュの実装

#### ・ハッシュ関数の改良
- ハッシュ値の衝突を減らしたい
- ただアルファベットと数値を対応させるのではなく、その文字が何文字目であるかという情報を含むようにすれば良いのでは？
- ハッシュ値 = (1文字目)*1 + (2文字目)*100 + (3文字目)*10000 + ...


### 実行結果について

配布されたSamplecodeと改良したhash_table.pyの実行時間を比較したグラフを以下に掲載する：

![宿題1の実行結果](step2023_week2_hashtable.pdf)

横軸をデータ数、縦軸を実行時間としている。
緑色がSamplecodeを実行した結果、紫色が提出したコードの実行結果である。
ハッシュ関数の改良や、再ハッシュの実装によって、O(1)に近づいたことがわかる。


## 宿題2
現実の大規模なデータベースでは、ハッシュテーブルではなく木構造が使われることが多い理由

- ハッシュテーブルは、以下の条件を満たす場合に、ほぼO(1)で動く
    - テーブルサイズが十分大きい
    - ハッシュ関数を適切に決定する
    - テーブルサイズが素数になるようにする


1. ハッシュテーブルでは、データ数に対して十分大きいテーブルサイズを確保する必要がある。しかし、データ数がわからないという状況下で適切なテーブルサイズを決めるのが困難である。これに対して、木構造では要素を追加する際にメモリを確保すれば良い。
2. データ数がどの程度になるか不明な状態で、ハッシュ関数を適切に決定するのは難しい。これによってハッシュの衝突が頻繁に起こってしまうと、最悪時間計算量がO(n)となってしまい、バランス木などの方が効率が良い。
3. ハッシュテーブルの方が必要以上にメモリを確保しておく必要があるため、空間計算量が多くなってしまう。
4. ハッシュテーブルの場合、要素の順番がバラバラに格納される。それに対して、木構造では要素を整列された状態で取り出すことができる。


## 宿題3

キャッシュの管理をほぼO(1)で実現できるデータ構造を考える。

- 結論：ハッシュテーブルと双方向リストを組み合わせることで、アクセス順序の管理を行えるようにする

- キャッシュに必要な機能は、以下の2つである：
    - アクセスしたページがキャッシュに存在している場合：アクセス順序を入れ替える
    - アクセスしたページがキャッシュに存在していない場合：
        - キャッシュに保存されているページ数が上限を超えている場合は、最も古い要素を削除して、新しい要素を追加する
        - キャッシュに保存されているページ数が上限未満の場合は、新しい要素を追加する
      
- アクセスしたページがキャッシュに存在するかどうかは、ハッシュテーブルを用いるとO(1)で調べることができる
- アクセス順序の管理をO(1)で行うことができるデータ構造が必要
    - ハッシュテーブルの各要素をリストで連結する
    - 双方向リストを用いると、新しい要素の追加と、古い要素の削除がO(1)で可能
        - 単方向リストでは、新しい要素か古い要素の削除のどちらかしかO(1)にならない             

## 宿題4
### プログラムの実行方法

### アルゴリズムの説明
### 工夫した点
