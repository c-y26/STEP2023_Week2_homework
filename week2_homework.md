# Week2

## 宿題1
- プログラムの実行方法
- アルゴリズムの説明
- 工夫した点
- 実行結果   
![task1_result](STEP2023_Week2_homework/step2023_week2_hash_table.pdf)

## 宿題2
現実の大規模なデータベースでは、ハッシュテーブルではなく木構造が使われることが多い理由

- ハッシュテーブルは、以下の条件を満たす場合に、ほぼO(1)で動く
    - テーブルサイズが十分大きい
    - ハッシュ関数を適切に決定する
    - テーブルサイズが素数になるようにする


1. ハッシュテーブルでは、データ数に対して十分大きいテーブルサイズを確保する必要がある。しかし、データ数がわからないという状況下で適切なテーブルサイズを決めるのが困難である。これに対して、木構造では要素を追加する際にメモリを確保すれば良い。
2. データ数がどの程度になるか不明な状態で、ハッシュ関数を適切に決定するのは難しい。これによってハッシュの衝突が頻繁に起こってしまうと、最悪時間計算量がO(n)となってしまい、バランス木などの方が効率が良い。
3. ハッシュテーブルの方が必要以上にメモリを確保しておく必要があるため、空間計算量が多くなってしまう。
4. ハッシュテーブルの場合、要素の順番がバラバラに格納される。それに対して、木構造では要素を整列された状態で取り出すことができる。


## 宿題3

キャッシュの管理をほぼO(1)で実現できるデータ構造を考える。

- 結論：ハッシュテーブルと双方向リストを組み合わせることで、アクセス順序の管理を行えるようにする

- キャッシュに必要な機能は、以下の2つである：
    - アクセスしたページがキャッシュに存在している場合：アクセス順序を入れ替える
    - アクセスしたページがキャッシュに存在していない場合：
        - キャッシュに保存されているページ数が上限を超えている場合は、最も古い要素を削除して、新しい要素を追加する
        - キャッシュに保存されているページ数が上限未満の場合は、新しい要素を追加する
      
- アクセスしたページがキャッシュに存在するかどうかは、ハッシュテーブルを用いるとO(1)で調べることができる
- アクセス順序の管理をO(1)で行うことができるデータ構造が必要
    - ハッシュテーブルの各要素をリストで連結する
    - 双方向リストを用いると、新しい要素の追加と、古い要素の削除がO(1)で可能
        - 単方向リストでは、新しい要素か古い要素の削除のどちらかしかO(1)にならない             

## 宿題4
- プログラムの実行方法
- アルゴリズムの説明
- 工夫した点
